#!/usr/bin/env python3
"""
STEP to OpenSCAD Converter

Converts STEP CAD files to OpenSCAD script format.
Uses gmsh for STEP parsing and STL mesh generation.

This provides maximum accuracy by converting the exact geometry to a mesh
that OpenSCAD can import.
"""

import argparse
import os
import sys
import tempfile
from pathlib import Path

import gmsh


def convert_step_to_stl(step_path: str, stl_path: str, mesh_size: float = 0.0) -> bool:
    """
    Convert a STEP file to STL using gmsh.
    
    Args:
        step_path: Path to input STEP file
        stl_path: Path for output STL file
        mesh_size: Mesh element size (0 for automatic)
    
    Returns:
        True if successful
    """
    gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 0)  # Suppress output
    
    try:
        # Import the STEP file
        gmsh.model.occ.importShapes(step_path)
        gmsh.model.occ.synchronize()
        
        # Get model bounds for auto mesh sizing
        if mesh_size <= 0:
            bounds = gmsh.model.getBoundingBox(-1, -1)
            xmin, ymin, zmin, xmax, ymax, zmax = bounds
            diagonal = ((xmax-xmin)**2 + (ymax-ymin)**2 + (zmax-zmin)**2)**0.5
            mesh_size = diagonal / 50  # Reasonable default
        
        # Set mesh size
        gmsh.option.setNumber("Mesh.CharacteristicLengthMin", mesh_size * 0.5)
        gmsh.option.setNumber("Mesh.CharacteristicLengthMax", mesh_size)
        
        # Generate 2D mesh (surface mesh for STL)
        gmsh.model.mesh.generate(2)
        
        # Write STL file
        gmsh.write(stl_path)
        
        return True
        
    except Exception as e:
        print(f"Error during conversion: {e}")
        return False
        
    finally:
        gmsh.finalize()


def analyze_step_geometry(step_path: str) -> dict:
    """
    Analyze a STEP file and return geometry information.
    
    Returns dict with:
        - bounds: (min, max) tuples
        - size: (dx, dy, dz)
        - entities: count of geometric entities
    """
    gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 0)
    
    try:
        gmsh.model.occ.importShapes(step_path)
        gmsh.model.occ.synchronize()
        
        # Get bounding box
        bounds = gmsh.model.getBoundingBox(-1, -1)
        xmin, ymin, zmin, xmax, ymax, zmax = bounds
        
        # Get entity counts
        volumes = gmsh.model.getEntities(dim=3)
        surfaces = gmsh.model.getEntities(dim=2)
        curves = gmsh.model.getEntities(dim=1)
        points = gmsh.model.getEntities(dim=0)
        
        return {
            'bounds_min': (xmin, ymin, zmin),
            'bounds_max': (xmax, ymax, zmax),
            'size': (xmax - xmin, ymax - ymin, zmax - zmin),
            'volumes': len(volumes),
            'surfaces': len(surfaces),
            'curves': len(curves),
            'points': len(points)
        }
        
    finally:
        gmsh.finalize()


def generate_openscad(stl_path: str, geometry_info: dict) -> str:
    """
    Generate OpenSCAD code that imports the STL mesh.
    
    Args:
        stl_path: Path to the STL file
        geometry_info: Dict with geometry analysis results
        
    Returns:
        OpenSCAD code as string
    """
    stl_basename = os.path.basename(stl_path)
    
    bounds_min = geometry_info['bounds_min']
    bounds_max = geometry_info['bounds_max']
    size = geometry_info['size']
    
    code = f'''// Generated by step_to_openscad.py
// Converted from STEP file

// Geometry Info:
// - Bounding box min: [{bounds_min[0]:.4f}, {bounds_min[1]:.4f}, {bounds_min[2]:.4f}]
// - Bounding box max: [{bounds_max[0]:.4f}, {bounds_max[1]:.4f}, {bounds_max[2]:.4f}]
// - Size: {size[0]:.4f} x {size[1]:.4f} x {size[2]:.4f}
// - Volumes: {geometry_info['volumes']}
// - Surfaces: {geometry_info['surfaces']}
// - Curves: {geometry_info['curves']}

$fn = 64;

// Import the mesh
// Note: The STL file must be in the same directory as this .scad file
import("{stl_basename}");

// Uncomment below to center the model at origin:
// translate([{-bounds_min[0] - size[0]/2:.4f}, {-bounds_min[1] - size[1]/2:.4f}, {-bounds_min[2] - size[2]/2:.4f}])
// import("{stl_basename}");

// Uncomment below to place model with corner at origin:
// translate([{-bounds_min[0]:.4f}, {-bounds_min[1]:.4f}, {-bounds_min[2]:.4f}])
// import("{stl_basename}");
'''
    
    return code


def convert_step_to_openscad(input_path: str, output_path: str = None, 
                              mesh_size: float = 0.0, verbose: bool = False) -> tuple:
    """
    Main conversion function.
    
    Args:
        input_path: Path to input STEP file
        output_path: Path for output OpenSCAD file (default: same name with .scad)
        mesh_size: Mesh element size (0 for automatic)
        verbose: Print detailed info
        
    Returns:
        Tuple of (scad_path, stl_path)
    """
    input_path = os.path.abspath(input_path)
    
    if not os.path.exists(input_path):
        raise FileNotFoundError(f"Input file not found: {input_path}")
    
    # Determine output paths
    if output_path is None:
        base = os.path.splitext(input_path)[0]
        output_path = base + ".scad"
    
    output_path = os.path.abspath(output_path)
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)
    
    # STL goes in same directory as output scad
    stl_path = os.path.splitext(output_path)[0] + ".stl"
    
    print(f"Input:  {input_path}")
    print(f"Output: {output_path}")
    print(f"Mesh:   {stl_path}")
    print()
    
    # Analyze geometry
    print("Analyzing STEP geometry...")
    geometry_info = analyze_step_geometry(input_path)
    
    print(f"  Bounding box: {geometry_info['bounds_min']} to {geometry_info['bounds_max']}")
    print(f"  Size: {geometry_info['size'][0]:.2f} x {geometry_info['size'][1]:.2f} x {geometry_info['size'][2]:.2f}")
    print(f"  Entities: {geometry_info['volumes']} volumes, {geometry_info['surfaces']} surfaces, {geometry_info['curves']} curves")
    print()
    
    # Convert to STL
    print("Converting to STL mesh...")
    success = convert_step_to_stl(input_path, stl_path, mesh_size)
    
    if not success:
        raise RuntimeError("Failed to convert STEP to STL")
    
    stl_size = os.path.getsize(stl_path)
    print(f"  Created {stl_path} ({stl_size:,} bytes)")
    print()
    
    # Generate OpenSCAD code
    print("Generating OpenSCAD file...")
    scad_code = generate_openscad(stl_path, geometry_info)
    
    with open(output_path, 'w') as f:
        f.write(scad_code)
    
    print(f"  Created {output_path}")
    print()
    print("Done! Open the .scad file in OpenSCAD to view the model.")
    
    return output_path, stl_path


def main():
    parser = argparse.ArgumentParser(
        description="Convert STEP files to OpenSCAD format",
        epilog="The output consists of an .scad file and an .stl mesh file."
    )
    parser.add_argument(
        "input", 
        help="Input STEP file path"
    )
    parser.add_argument(
        "-o", "--output",
        help="Output OpenSCAD file path (default: same name with .scad extension)"
    )
    parser.add_argument(
        "-m", "--mesh-size",
        type=float,
        default=0.0,
        help="Mesh element size (default: automatic based on model size)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Verbose output"
    )
    
    args = parser.parse_args()
    
    try:
        scad_path, stl_path = convert_step_to_openscad(
            args.input, 
            args.output,
            args.mesh_size,
            args.verbose
        )
        sys.exit(0)
        
    except Exception as e:
        print(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
